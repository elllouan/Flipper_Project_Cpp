A shader is a program that runs on the GPU. It is used to render shapes
out on the screen. There exist multiple shaders but here are the most common
ones:
- vertex shader: determines the position of each position vertex on the screen.
- geometry shader: 
- fragment shader: determines the color of each pixel on the shapes that was displayed.

The fragment shader is much more expensive operation because it gets called as many times
as the number of pixels there are within the shape defined by the vertex shader.

CHAP 1: OpenGL objects and graphics pipeline

The graphics pipeline is:
GPU -> vertex shader -> fragment shader -> screen

Some definitions:
- A fragment 
	is all the data required for OpenGL to render a single pixel.
- VBO for Vertex Buffer Object 
	is an OpenGL object that aims to store raw data such as position, color, textture, brightness ...
- VAO for Vertex Array Object 
	is an OpenGL object that aims to tell how to access the data of a bounded VBO.
https://www.youtube.com/watch?v=Ktp1P4J04Gw
- EBO for Element Buffer Object
	is a buffer, just like a VBO, that stores indices that OpenGL uses to decide what vertices to draw. It helps avoiding overlapping.


Steps to follow to render sth out:
Manage OpenGL objects:
	1. glGenBuffer or glGenVertexArrays: generate VBO, EBO or VAO.
	2. glBindBuffer or glBindVertexArray: bind VBO, EBO or VAOto the current context.
	3. glBufferData (for VBO and EBO): specify details about data for each buffer.
	4. glVertexAttribPointer: specify how to access attributes of the bounded VBO.
	5. glEnableVertexArray

Create simple shaders:
	1. 
	2.
	3.
	4.
	5.
	6.

Methods encountered:
glGen[Buffers/Arrays], glBind[Buffers/Arrays], glVertexAttribPointer, glEnableVertexAttribArray, glDraw[Buffers/Arrays],
glCreate[Shader/Program], glCompileShader, glAttachShader, glLinkProgram, glValidateProgram, glDelete[Buffers/Arrays/Shader],
glUseProgram, glDeleteProgram


CHAP 2: Shaders and uniforms with GLSL

	1. Transfer data from one shader to another one by using 'in' and 'out' keywords.
	2. Uniforms are another way to pass data from our application on the CPU to the shaders on the GPU.
		They are global variables that can be accesed from any shader and also from the code.
		Finding the uniform location does not require you to use the shader program first,
		but updating a uniform does require you to first use the program (by calling glUseProgram),
		because it sets the uniform on the currently active shader program.
	3. 

Methods encountered:
glDrawElements, glUniform, glGetUniformLocation, glUniform[1/2/3/4][f/i/b]


CHAP 3: Textures

	1. Texture wrapping: GL_[MIRRORED]_REPEAT / GL_CLAMP_TO_[EDGE/BORDER]
	2. Filtering methods: GL_[LINEAR/NEAREST] for magnifying (scaling upwards) or minifying (scaling downwards) a texture
	3. Mipmaps helps limiting the overhead of rendering small pieces of texture that are located next to bigger high resolution textures.
		It is a collection of texture images where each subsequent texture is twice as small compared to the previous one.
	4. Loading various type of images with stb_image.h
	5. Generating a texture
	6. Samplers ...

Methods encountered:
glTexParameter[f/i/iv/fv], glGenerateMipmap, glGenTextures, glBindTexture[s], glTexImage[1/2/3]D, 
